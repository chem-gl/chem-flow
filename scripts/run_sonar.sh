#!/usr/bin/env bash
set -euo pipefail

# run_sonar.sh — ayuda mejorada para ejecutar SonarScanner en este repositorio
# Ejemplos de uso:
#   SONAR_TOKEN="<token>" ./scripts/run_sonar.sh            # usa valores por defecto y ejecuta build/test
#   SONAR_TOKEN="<token>" ./scripts/run_sonar.sh --skip-build --host http://host:9000
#   ./scripts/run_sonar.sh --token-arg --skip-build          # solicita el token interactivamente
#
# IMPORTANTE: Nunca subas tokens al repositorio. Proporciona el token mediante la
# variable de entorno SONAR_TOKEN o usa --token-arg para introducirlo en runtime.

REPO_ROOT="$(cd "$(dirname "$0")/.." && pwd)"
cd "$REPO_ROOT"

# Defaults
DEFAULT_HOST="http://hamster-dektop:9000"
PROJECT_KEY_DEFAULT="flow-chem"
SONAR_SDK_VERSION="4.8.0.2856"
SONAR_SCANNER_ZIP="sonar-scanner-cli-${SONAR_SDK_VERSION}-linux.zip"
SCANNER_DIR="scanner/sonar-scanner-${SONAR_SDK_VERSION}-linux"

# CLI flags
HOST="${SONAR_HOST_URL:-$DEFAULT_HOST}"
PROJECT_KEY="$PROJECT_KEY_DEFAULT"
# Default to skip build and download scanner to match your workflow preference
SKIP_BUILD=1
FORCE_DOWNLOAD=1
TOKEN_FROM_ARG=0
GEN_COVERAGE=0

usage() {
  sed -n '1,240p' "$0"
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --host)
      HOST="$2"; shift 2;;
    --project-key)
      PROJECT_KEY="$2"; shift 2;;
    --skip-build)
      SKIP_BUILD=1; shift;;
    --download|--force-download)
      FORCE_DOWNLOAD=1; shift;;
    --coverage|--generate-coverage)
      GEN_COVERAGE=1; shift;;
    --token-arg)
      TOKEN_FROM_ARG=1; shift;;
    --help|-h)
      usage; exit 0;;
    *)
      echo "Unknown arg: $1"; usage; exit 2;;
  esac
done

# Acquire token
if [[ -n "${SONAR_TOKEN:-}" ]]; then
  TOKEN="${SONAR_TOKEN}"
elif [[ $TOKEN_FROM_ARG -eq 1 ]]; then
  read -rp "Paste Sonar token (input will be hidden): " -s TOKEN
  echo
else
  echo "Error: SONAR_TOKEN no está configurada. Establece la variable SONAR_TOKEN o ejecuta con --token-arg para introducirla interactivamente." >&2
  exit 2
fi

# Security reminder
cat <<'WARN'
ADVERTENCIA: No comites tokens en el repositorio ni los pegues en chats públicos.
Si el token fue expuesto, revócalo inmediatamente y genera uno nuevo.
WARN

# Optional build/test
if [[ $SKIP_BUILD -eq 0 ]]; then
  echo "Running build & tests"
    if command -v cargo >/dev/null 2>&1; then
    cargo fmt --all -- --check || true
    cargo build --workspace --verbose
    cargo test --workspace --verbose
  else
    echo "cargo no encontrado; se omiten comprobaciones de build/test" >&2
  fi
else
  echo "Skipping build/tests as requested (--skip-build)"
fi

# Optionally generate coverage locally (useful for local sonar runs)
if [[ $GEN_COVERAGE -eq 1 ]]; then
  if command -v cargo-tarpaulin >/dev/null 2>&1 || command -v cargo-tarpaulin-0.20 >/dev/null 2>&1; then
    echo "Generating LCOV coverage via cargo-tarpaulin"
    cargo tarpaulin --out Lcov || echo "tarpaulin failed"
  else
    echo "cargo-tarpaulin not installed locally. If you want coverage, run inside Docker app-dev or install tarpaulin." >&2
  fi
fi

# Ensure scanner is downloaded
if [[ $FORCE_DOWNLOAD -eq 1 || ! -x "${SCANNER_DIR}/bin/sonar-scanner" ]]; then
  echo "Downloading sonar-scanner ${SONAR_SDK_VERSION}..."
  mkdir -p scanner
  wget -qO scanner.zip "https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/${SONAR_SCANNER_ZIP}"
  # If forcing a download, remove any previously extracted scanner dir so unzip won't prompt to replace files.
  if [[ -d "${SCANNER_DIR}" && ${FORCE_DOWNLOAD} -eq 1 ]]; then
    echo "Removing existing scanner dir ${SCANNER_DIR} to avoid unzip prompts"
    rm -rf "${SCANNER_DIR}"
  fi
  # Use -o to overwrite without prompting and -q for quiet
  unzip -o -q scanner.zip -d scanner
  rm -f scanner.zip
fi

SCANNER_BIN="$REPO_ROOT/${SCANNER_DIR}/bin/sonar-scanner"
  if [[ ! -x "$SCANNER_BIN" ]]; then
  echo "sonar-scanner no encontrado en $SCANNER_BIN" >&2
  exit 2
fi

export PATH="$REPO_ROOT/${SCANNER_DIR}/bin:$PATH"

# Ensure coverage file exists (scan only mode for Sonar)
DEFAULT_LCOV="$REPO_ROOT/coverage/lcov.info"
COVERAGE_PATH=""
PREFERRED_GENERIC="$REPO_ROOT/coverage/sonar-generic-coverage.xml"
# If COVERAGE_PATH is already set and points to a file, acknowledge it; otherwise note we'll search
if [[ -n "$COVERAGE_PATH" && -f "$COVERAGE_PATH" ]]; then
  echo "Found coverage at $COVERAGE_PATH"
else
  echo "Nota: aún no se eligió reporte de cobertura. Buscaremos informes disponibles en coverage/." >&2
fi

# Prefer Cobertura XML if present (Sonar Generic Coverage importer expects XML).
# If only LCOV exists, try to convert it to Cobertura XML using python3 (if available).
# Prefer a Sonar-generic file generated by the Docker coverage step
if [[ -f "$PREFERRED_GENERIC" ]]; then
  COVERAGE_PATH="$PREFERRED_GENERIC"
  echo "Using sonar-generic coverage: $COVERAGE_PATH"
elif compgen -G "$REPO_ROOT/coverage/*.xml" >/dev/null 2>&1; then
  # pick the first XML report (commonly coverage/cobertura.xml or tarpaulin XML)
  FIRST_XML=$(ls -1 "$REPO_ROOT/coverage"/*.xml | head -n1)
  echo "Using existing coverage XML: $FIRST_XML"
  COVERAGE_PATH="$FIRST_XML"
else
  # No XML; attempt to convert lcov to cobertura.xml when python3 is available
  if [[ -f "$DEFAULT_LCOV" ]]; then
    if command -v python3 >/dev/null 2>&1; then
      echo "No se encontró Cobertura XML — intentando convertir coverage/lcov.info -> coverage/cobertura.xml usando python3"
      set +e
      python3 - <<'PY'
import os,sys,xml.etree.ElementTree as ET,time
repo=os.getcwd()
lcov=os.path.join(repo,'coverage','lcov.info')
out=os.path.join(repo,'coverage','cobertura.xml')
if not os.path.exists(lcov):
    print('lcov.info not found',file=sys.stderr); sys.exit(2)
packages={}
cur=None
relmap={}
with open(lcov,'r',encoding='utf-8',errors='replace') as f:
    for ln in f:
        ln=ln.strip()
        if ln.startswith('SF:'):
            path=ln[3:]
            if os.path.isabs(path) and path.startswith(repo):
                rel=os.path.relpath(path,repo)
            else:
                rel=path
            cur=rel
            packages.setdefault(cur,[])
        elif ln.startswith('DA:') and cur:
            parts=ln[3:].split(',')
            try:
                line_no=int(parts[0]); hits=int(parts[1])
            except Exception:
                continue
            packages[cur].append((line_no,hits))
        elif ln=='end_of_record':
            cur=None

# Build a minimal Cobertura XML
coverage=ET.Element('coverage',{
    'line-rate':'0.0','branch-rate':'0.0','version':'lcov-to-cobertura','timestamp':str(int(time.time()))
})
packages_el=ET.SubElement(coverage,'packages')
pkg_el=ET.SubElement(packages_el,'package',{'name':'.','line-rate':'0.0','branch-rate':'0.0'})
classes_el=ET.SubElement(pkg_el,'classes')
for fname,lines in packages.items():
    class_el=ET.SubElement(classes_el,'class',{'name':fname.replace('/','.'),'filename':fname,'line-rate':'0.0','branch-rate':'0.0'})
    lines_el=ET.SubElement(class_el,'lines')
    for ln_no,hits in sorted(lines):
        ET.SubElement(lines_el,'line',{'number':str(ln_no),'hits':str(hits)})

tree=ET.ElementTree(coverage)
tree.write(out,encoding='utf-8',xml_declaration=True)
print(out)
PY
      CONV_EXIT=$?
      set -e
      if [[ $CONV_EXIT -eq 0 && -f "$REPO_ROOT/coverage/cobertura.xml" ]]; then
        COVERAGE_PATH="$REPO_ROOT/coverage/cobertura.xml"
        echo "LCOV convertido a Cobertura: coverage/cobertura.xml"
      else
        echo "La conversión falló (exit=$CONV_EXIT) o no se produjo cobertura.xml. Sonar podría no importar LCOV directamente." >&2
      fi
    else
      echo "python3 not available; cannot auto-convert lcov.info to Cobertura XML. Run './scripts/generate_coverage.sh' to produce XML or install a converter." >&2
    fi
  fi
fi

# Run sonar-scanner and fail on non-zero exit
echo "Running sonar-scanner against host: $HOST (projectKey: $PROJECT_KEY)"

# If the chosen coverage path is an XML file (e.g., Cobertura), Sonar may expect
# the Generic coverage XML format (version 1). Convert Cobertura -> Sonar Generic
# when possible to avoid "Unknown report version" parsing errors.
if [[ "$COVERAGE_PATH" == *.xml && -f "$COVERAGE_PATH" ]]; then
  if command -v python3 >/dev/null 2>&1; then
  echo "Convirtiendo XML de cobertura ($COVERAGE_PATH) -> Sonar generic coverage (coverage/sonar-generic-coverage.xml)"
    set +e
    # Export the input path so the embedded Python can read it reliably
    export COV_IN="$COVERAGE_PATH"
    python3 - <<'PY'
import os,sys,xml.etree.ElementTree as ET
cov_in = os.environ.get('COV_IN')
if not cov_in or not os.path.isfile(cov_in):
  print('No coverage input found', file=sys.stderr); sys.exit(2)
try:
  tree = ET.parse(cov_in)
  root = tree.getroot()
except Exception as e:
  print('Failed to parse coverage XML:', e, file=sys.stderr); sys.exit(3)

# Prepare output
out = os.path.join(os.path.dirname(cov_in), 'sonar-generic-coverage.xml')
cov = ET.Element('coverage', {'version': '1'})

# Cobertura layout: packages -> package -> classes -> class -> lines -> line
ns_lines = []
def collect_lines_from_cobertura(root):
  lines_map = {}
  # Find all <class> elements
  for class_el in root.findall('.//class'):
    filename = class_el.get('filename') or class_el.get('name')
    if not filename:
      continue
    # normalize path
    fname = filename
    # lines under class
    for lines_el in class_el.findall('.//lines'):
      for line in lines_el.findall('line'):
        num = line.get('number')
        hits = line.get('hits') or line.get('count') or line.get('hit')
        try:
          covered = 'true' if int(hits or '0')>0 else 'false'
        except Exception:
          covered = 'false'
        lines_map.setdefault(fname, {})[int(num)] = covered
  # Also handle Cobertura root with <packages>/<package>/<classes> etc handled above
  return lines_map

lines_map = collect_lines_from_cobertura(root)

# If no lines found, maybe it's already Sonar Generic or another XML. Try generic detection.
if not lines_map:
  # detect existing generic format: <coverage version="1">/<file path=>/<lineToCover/>
  if root.tag == 'coverage' and root.get('version') == '1':
    print('Coverage already in Sonar generic format; no conversion needed')
    print(cov_in)
    sys.exit(0)
  else:
    print('No class/line entries found in coverage XML; conversion skipped', file=sys.stderr)
    sys.exit(4)

for fname,lines in lines_map.items():
  file_el = ET.SubElement(cov, 'file', {'path': fname})
  for ln,covered in sorted(lines.items()):
    ET.SubElement(file_el, 'lineToCover', {'lineNumber': str(ln), 'covered': covered})

tree = ET.ElementTree(cov)
tree.write(out, encoding='utf-8', xml_declaration=True)
print(out)
PY
  CONV_EXIT=$?
  set -e
  if [[ $CONV_EXIT -eq 0 && -f "$REPO_ROOT/coverage/sonar-generic-coverage.xml" ]]; then
    COVERAGE_PATH="$REPO_ROOT/coverage/sonar-generic-coverage.xml"
    echo "Using converted Sonar generic coverage: $COVERAGE_PATH"
  else
    echo "La conversión de XML de cobertura falló (exit=$CONV_EXIT). Continuando con el archivo original: $COVERAGE_PATH" >&2
  fi
  else
  echo "python3 no disponible; no se puede convertir Cobertura XML a formato Sonar generic. Sonar puede rechazar el reporte." >&2
  fi
fi

# Check local Java version. SonarScanner 4.8+ requires Java 17+. If local java is older,
# fall back to running scanner inside a Docker image that includes a newer JDK.
USE_DOCKER_FALLBACK=0
if command -v java >/dev/null 2>&1; then
  JAVA_VER_STR=$(java -version 2>&1 | awk -F '"' 'NR==1{print $2}') || JAVA_VER_STR=""
  JAVA_MAJOR=${JAVA_VER_STR%%.*}
  if [[ -n "$JAVA_MAJOR" && "$JAVA_MAJOR" -ge 17 ]]; then
    echo "Detected Java major version: $JAVA_MAJOR (suitable)"
  else
    echo "Detected Java major version: ${JAVA_MAJOR:-unknown} — will use Docker fallback for sonar-scanner"
    USE_DOCKER_FALLBACK=1
  fi
else
  echo "Java not found — will use Docker fallback for sonar-scanner"
  USE_DOCKER_FALLBACK=1
fi

set +e
if [[ $USE_DOCKER_FALLBACK -eq 0 ]]; then
  # Before running the locally-downloaded scanner binary, check if the scanner
  # ships its own JRE (scanner/.../jre). If that bundled JRE is older than 17
  # it will cause the UnsupportedClassVersionError. Prefer system java when
  # available — we temporarily disable the bundled JRE by renaming it.
  BUNDLED_JRE_DIR="$REPO_ROOT/${SCANNER_DIR}/jre"
  RENAMED_JRE_DIR=""
  if [[ -d "$BUNDLED_JRE_DIR" && -x "$BUNDLED_JRE_DIR/bin/java" ]]; then
    BUNDLED_VER_STR=$("$BUNDLED_JRE_DIR/bin/java" -version 2>&1 | awk -F '"' 'NR==1{print $2}') || BUNDLED_VER_STR=""
    BUNDLED_MAJOR=${BUNDLED_VER_STR%%.*}
    if [[ -z "$BUNDLED_MAJOR" || "$BUNDLED_MAJOR" -lt 17 ]]; then
      echo "Bundled scanner JRE detected at $BUNDLED_JRE_DIR with version ${BUNDLED_VER_STR:-unknown} (<17): disabling it to use system Java."
      RENAMED_JRE_DIR="${BUNDLED_JRE_DIR}.disabled.$(date +%s)"
      mv "$BUNDLED_JRE_DIR" "$RENAMED_JRE_DIR" || true
    fi
  fi

  # Run the scanner by invoking the scanner CLI jar directly with system java to
  # avoid the wrapper script forcing a bundled (older) JRE.
  JAR_FILE="$REPO_ROOT/${SCANNER_DIR}/lib/sonar-scanner-cli-${SONAR_SDK_VERSION}.jar"
  if [[ ! -f "$JAR_FILE" ]]; then
    echo "Scanner jar not found at $JAR_FILE" >&2
    SCANNER_EXIT=1
  else
    JAVA_CMD="$(which java || true)"
    if [[ -z "$JAVA_CMD" ]]; then
      echo "java no encontrado en PATH; no se puede ejecutar el jar del scanner" >&2
      SCANNER_EXIT=1
    else
      echo "Ejecutando el jar del scanner directamente con $JAVA_CMD"
      "$JAVA_CMD" -Djava.awt.headless=true \
        -classpath "$JAR_FILE" \
        -Dscanner.home="$REPO_ROOT/${SCANNER_DIR}" \
        -Dproject.home="$(pwd)" \
        org.sonarsource.scanner.cli.Main \
        -Dsonar.projectKey="$PROJECT_KEY" \
        -Dsonar.sources=crates,src \
        -Dsonar.host.url="$HOST" \
        -Dsonar.login="$TOKEN" \
        -Dsonar.coverageReportPaths="$COVERAGE_PATH"
      SCANNER_EXIT=$?
    fi
  fi
  # Optionally restore the renamed JRE (we leave it disabled to avoid re-triggering the issue)
  if [[ -n "$RENAMED_JRE_DIR" && -d "$RENAMED_JRE_DIR" ]]; then
    echo "Nota: JRE embebido del scanner movido a $RENAMED_JRE_DIR" >&2
  fi
else
  # Ensure Docker is available
  if ! command -v docker >/dev/null 2>&1; then
    echo "Error: Docker not available and local Java is <17. Install Java 17 (e.g. openjdk-17-jdk) or install Docker to run the scanner in a container." >&2
    exit 2
  fi

  DOCKER_IMAGE="sonarsource/sonar-scanner-cli:4.8.0.2856"
  echo "Ejecutando sonar-scanner vía imagen Docker: $DOCKER_IMAGE"
  docker run --rm -v "$REPO_ROOT":/usr/src -w /usr/src "$DOCKER_IMAGE" \
    -Dsonar.projectKey="$PROJECT_KEY" \
    -Dsonar.sources=crates,src \
    -Dsonar.host.url="$HOST" \
    -Dsonar.login="$TOKEN" \
    -Dsonar.coverageReportPaths="$COVERAGE_PATH"
  SCANNER_EXIT=$?
fi
set -e

if [[ $SCANNER_EXIT -ne 0 ]]; then
  echo "sonar-scanner falló con código de salida $SCANNER_EXIT" >&2
  echo "Si aparece un error de versión de clases Java, instala Java 17+ localmente (ej. 'sudo apt install openjdk-17-jdk') o asegúrate de que Docker esté disponible." >&2
  exit $SCANNER_EXIT
fi

# Escaneo Sonar finalizado. Revisa $HOST para ver resultados (project key: $PROJECT_KEY).

# Unset token in current shell to avoid leaking into later commands
unset TOKEN

exit 0
